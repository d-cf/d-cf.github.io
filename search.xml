<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ADS Dynamic programming</title>
      <link href="2021/06/04/ADS-Dynamic%20programming/"/>
      <url>2021/06/04/ADS-Dynamic%20programming/</url>
      
        <content type="html"><![CDATA[<h2 id="Dynamic-Programming-part-1"><a href="#Dynamic-Programming-part-1" class="headerlink" title="Dynamic  Programming(part 1)"></a><center>Dynamic  Programming(part 1)</center></h2><p>​    Solve sub-problems just once and save answers in a table.</p><p>​    Use a table instead of recursion(个人感觉DP和DC不同的地方在于一个是用时间换空间(DC)，一个是空间换时间(DP))</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><h5 id="1、Fibonacci-Numbers"><a href="#1、Fibonacci-Numbers" class="headerlink" title="1、Fibonacci Numbers:"></a>1、Fibonacci Numbers:</h5><p>​    F(N)=F(N-1)+F(N-2)</p><p>​    递归实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Fib</span><span class="params">( <span class="keyword">int</span> N )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> ( N &lt;= <span class="number">1</span> ) </span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>  </span><br><span class="line">        <span class="built_in">Fib</span>( N - <span class="number">1</span> ) + <span class="built_in">Fib</span>( N - <span class="number">2</span> ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于T(N)=T(N-1)+T(N-2)+2, T(N)&gt;=T(N-1)+T(N-2)——&gt;T(N)&gt;=F(N),</p><p>而Fibonacci number 是指数级增长的，所以时间复杂度也是指数级！！！</p><p>Trouble Maker: the growth of the redundant calculations is explosive.</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Fibonacci</span> <span class="params">( <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>  i, Last, NextToLast, Answer; </span><br><span class="line">    <span class="keyword">if</span> ( N &lt;= <span class="number">1</span> )  </span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>; </span><br><span class="line">    Last = NextToLast = <span class="number">1</span>;    <span class="comment">/* F(0) = F(1) = 1 */</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">2</span>; i &lt;= N; i++ ) &#123; </span><br><span class="line">        Answer = Last + NextToLast;   <span class="comment">/* F(i) = F(i-1) + F(i-2) */</span></span><br><span class="line">        NextToLast = Last; Last = Answer;  <span class="comment">/* update F(i-1) and F(i-2) */</span></span><br><span class="line">    &#125;  <span class="comment">/* end-for */</span></span><br><span class="line">    <span class="keyword">return</span>  Answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(N)=O(N)</p><p>(这里说明DC是从上到下解决问题，而DP是从下到上解决问题)</p><h5 id="2、Ordering-Matrix-Multiplications"><a href="#2、Ordering-Matrix-Multiplications" class="headerlink" title="2、Ordering Matrix Multiplications"></a>2、Ordering Matrix Multiplications</h5><p>example: Suppose we are to multiply 4 matrices</p><p>​    M<sub>1[10<em>20]</sub> * M<sub>2[20</em>50]</sub> * M<sub>3[50<em>1]</sub> * M<sub>4[1</em>100]</sub> </p><p>If we multiply in the order</p><p>​    M<sub>1[10<em>20]</sub> * (M<sub>2[20</em>50]</sub> * (M<sub>3[50<em>1]</sub> * M<sub>4[1</em>100]</sub> ))</p><p>Then the computing time is </p><p>​    50 * 1 * 100+ 20 * 50 * 100+ 10 * 20 * 100=125000</p><p>If we multiply in the order</p><p>​    (M<sub>1[10<em>20]</sub> * (M<sub>2[20</em>50]</sub> * M<sub>3[50<em>1]</sub>)) * M<sub>4[1</em>100]</sub> </p><p>Then the computing time is </p><p>​    20 * 50 * 1+ 10 * 20 * 1+10 * 1 * 100=2200</p><p>Problem: In which order can we compute the product of n matrices with minimal computing time?</p><p>Let b<sub>n</sub>  = number of different ways to compute M1*M2……Mn.  Then we have  b<sub>2</sub>  = 1, b<sub>3</sub>  = 2, b<sub>4</sub>  = 5,</p><p>……</p><p> Let M<sub>ij</sub> =M<sub>i</sub> ……M<sub>j</sub> . Then M<sub>1n</sub> =M<sub>1</sub> ……M<sub>n</sub> =M<sub>1i</sub> * M<sub>i+1 n</sub> </p><p>—–&gt;b<sub>n</sub> = b<sub>i</sub> b<sub>n-i</sub> (求和) ——-&gt;b<sub>n</sub> 是一个比指数增长略慢一点的序列，但是还是增长很快，所以无法进行枚举来判断哪个情况更好。</p><p>​    Suppose we are to multiply  n  matrices M<sub>1</sub> ……M<sub>n</sub> where M<sub>i</sub>  is an r<sub>i-1</sub> * r<sub>i</sub> matrix.  Let m<sub>ij</sub> be the cost of the optimal way to compute M<sub>i</sub> ……M<sub>j</sub> .  Then we have the recurrence equations:</p><p>m<sub>ij</sub> =0(if i=j)</p><p>​      =min{ m<sub>il</sub> + m<sub>l+1 j</sub> +r<sub>i-1</sub> r<sub>l</sub> r<sub>j</sub> } (i&lt;=l&lt;=j) if(j&gt;i)</p><p>There are only O(N<sup>2</sup> ) values of M<sub>ij</sub> .</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* r contains number of columns for each of the N matrices */</span></span><br><span class="line"><span class="comment">/* r[ 0 ] is the number of rows in matrix 1 */</span></span><br><span class="line"><span class="comment">/* Minimum number of multiplications is left in M[ 1 ][ N ] */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OptMatrix</span><span class="params">( <span class="keyword">const</span> <span class="keyword">long</span> r[ ], <span class="keyword">int</span> N, TwoDimArray M )</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>  i, j, k, L; </span><br><span class="line">    <span class="keyword">long</span>  ThisM; </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt;= N; i++ )   M[ i ][ i ] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>( k = <span class="number">1</span>; k &lt; N; k++ ) <span class="comment">/* k = j - i */</span> </span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt;= N - k; i++ ) &#123; <span class="comment">/* For each position */</span> </span><br><span class="line">            j = i + k;    M[ i ][ j ] = Infinity; </span><br><span class="line">            <span class="keyword">for</span>( L = i; L &lt; j; L++ ) &#123; </span><br><span class="line">                ThisM = M[ i ][ L ] + M[ L + <span class="number">1</span> ][ j ] + r[ i - <span class="number">1</span> ] * r[ L ] * r[ j ]; </span><br><span class="line">                <span class="keyword">if</span> ( ThisM &lt; M[ i ][ j ] )  <span class="comment">/* Update min */</span> </span><br><span class="line">                    M[ i ][ j ] = ThisM; </span><br><span class="line">            &#125;  <span class="comment">/* end for-L */</span></span><br><span class="line">        &#125;  <span class="comment">/* end for-Left */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(N)=O(N<sup>3</sup> ).</p><h5 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h5><p>—–the best for static searching(without insertion and deletion)</p><p>​    Given  N words  w1 &lt; w2 &lt; …… &lt; wN, and the probability of searching for each  wi is  pi .  Arrange these words in a binary search tree in a way that minimize the expected total access time.</p><p>​    T(N)(时间复杂度，和下面的T<sub>ij</sub> 不同，和c<sub>ij</sub> 相差不多)=p<sub>k</sub> * (1+d<sub>i</sub> (深度)).</p><p>T<sub>ij</sub> ::=OBST for w<sub>i</sub> ,……,w<sub>j</sub> (i&lt;j)</p><p>c<sub>ij</sub> ::=cost of T<sub>ij</sub> (c<sub>ii</sub> =0)</p><p>r<sub>ij</sub> ::=root of T<sub>ij</sub> </p><p>w<sub>ij</sub> ::=weight of T<sub>ij</sub> =p<sub>k</sub> (加和)(k=i—&gt;j)(w<sub>ii</sub> =p<sub>i</sub> )</p><p>c<sub>ij</sub> =p<sub>k</sub> + c<sub>i,k-1</sub> + c<sub>k+1,j</sub> +w<sub>i,k-1</sub> + w<sub>k+1,j</sub> =w<sub>ij</sub> +c<sub>i,k-1</sub> + c<sub>k+1,j</sub> .</p><p>T<sub>ij</sub> is optimal —-&gt; r<sub>ij</sub> =k is such that c<sub>ij</sub> =min{w<sub>ij</sub> +c<sub>i,l-1</sub> + c<sub>l+1,j</sub> }</p><p>(详细操作见ppt)</p><p>T(N)=O(N<sup>3</sup>)</p><h5 id="All-Pairs-Shortest-Path"><a href="#All-Pairs-Shortest-Path" class="headerlink" title="All-Pairs Shortest Path"></a>All-Pairs Shortest Path</h5><p>​    For all pairs of v<sub>i</sub> and v<sub>j</sub> (i!=j),find the shortest path between.</p><p>​    Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A[ ] contains the adjacency matrix with A[ i ][ i ] = 0 */</span> </span><br><span class="line"><span class="comment">/* D[ ] contains the values of the shortest path */</span> </span><br><span class="line"><span class="comment">/* N is the number of vertices */</span> </span><br><span class="line"><span class="comment">/* A negative cycle exists iff D[ i ][ i ] &lt; 0 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllPairs</span><span class="params">( TwoDimArray A, TwoDimArray D, <span class="keyword">int</span> N )</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>  i, j, k; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; N; i++ )  <span class="comment">/* Initialize D */</span> </span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; N; j++ )</span><br><span class="line">            D[ i ][ j ] = A[ i ][ j ]; </span><br><span class="line">    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; N; k++ )  <span class="comment">/* add one vertex k into the path */</span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ ) </span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; N; j++ ) </span><br><span class="line">                <span class="keyword">if</span>( D[ i ][ k ] + D[ k ][ j ] &lt; D[ i ][ j ] ) </span><br><span class="line">                    <span class="comment">/* Update shortest path */</span> </span><br><span class="line">                    D[ i ][ j ] = D[ i ][ k ] + D[ k ][ j ]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(N)=O(N<sup>3</sup>)</p><h5 id="Product-Assembly"><a href="#Product-Assembly" class="headerlink" title="Product Assembly"></a>Product Assembly</h5><p>Two assembly lines for the same car.</p><p>Different technology (time) for each stage</p><p>One can change lines between stages</p><p>Minimize the total assembly time</p><p>Exhaustive search gives O( 2<sup>N</sup> ) time + O( N ) space</p><h6 id="Characterize-an-optimal-solution"><a href="#Characterize-an-optimal-solution" class="headerlink" title="Characterize an optimal solution"></a>Characterize an optimal solution</h6><p>​    An optimal solution contains an optimal solution of </p><p>a sub-problem!(反证法很好证)</p><h6 id="Recursively-define-the-optimal-values"><a href="#Recursively-define-the-optimal-values" class="headerlink" title="Recursively define the optimal values"></a>Recursively define the optimal values</h6><p>​    An optimal path to stage is based on an optimal path to stage–1</p><h6 id="Compute-the-values-in-some-order"><a href="#Compute-the-values-in-some-order" class="headerlink" title="Compute the values in some order"></a>Compute the values in some order</h6><p>​    f[line] [stage] = min{</p><p>​                    f[line] [stage-1] + t_process[line] [stage-1],</p><p>​                    f[1-line] [stage-1] + t_transit[1-line] [stage-1]}</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;  f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (stage=<span class="number">1</span>; stage&lt;=n; stage++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (line=<span class="number">0</span>; line&lt;=<span class="number">1</span>; line++)&#123;</span><br><span class="line">        f[line] [stage] = <span class="built_in">min</span>(</span><br><span class="line">f[line] [stage<span class="number">-1</span>] + t_process[line] [stage<span class="number">-1</span>],</span><br><span class="line">f[<span class="number">1</span>-line] [stage<span class="number">-1</span>] + t_transit[<span class="number">1</span>-line] [stage<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Solution = <span class="built_in">min</span>(f[<span class="number">0</span>][n],f[<span class="number">1</span>][n]);</span><br></pre></td></tr></table></figure><p>T(N)=O(N).</p><p>O(N)(time)+O(N)(space)</p><p>Reconstruct the solving strategy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; L[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>; L[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(stage=<span class="number">1</span>; stage&lt;=n; stage++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(line=<span class="number">0</span>; line&lt;=<span class="number">1</span>; line++)&#123;</span><br><span class="line">        f_stay = f[  line][stage<span class="number">-1</span>] + t_process[  line][stage<span class="number">-1</span>];</span><br><span class="line">        f_move = f[<span class="number">1</span>-line][stage<span class="number">-1</span>] + t_transit[<span class="number">1</span>-line][stage<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (f_stay&lt;f_move)&#123;</span><br><span class="line">            f[line][stage] = f_stay;</span><br><span class="line">            L[line][stage] = line;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[line][stage] = f_move;</span><br><span class="line">            L[line][stage] = <span class="number">1</span>-line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">line = f[<span class="number">0</span>][n]&lt;f[<span class="number">1</span>][n]?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(stage=n; stage&gt;<span class="number">0</span>; stage--)</span><br><span class="line">&#123;</span><br><span class="line">    plan[stage] = line;</span><br><span class="line">    line = L[line][stage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When can’t we apply dynamic we apply dynamic programming?</p><p>​    History-dependency</p><p>​    sub-problems do not overlap(这是DC更有效)</p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ADS chapter6 Binomial Queue</title>
      <link href="2021/06/03/ADS-chapter6/"/>
      <url>2021/06/03/ADS-chapter6/</url>
      
        <content type="html"><![CDATA[<h2 id="Binomial-Queue"><a href="#Binomial-Queue" class="headerlink" title="Binomial Queue"></a><center>Binomial Queue</center></h2><p>​    Target: 为什么有了Binomial Queue？优化Leftist heaps和Skew heaps的insert操作！(但是我感觉ppt上说的不太对，对于一个普通的堆来说，插入操作的时间复杂度为log(N)，对于Leftist heaps和Skew heaps也是log(N)；有N个数字，然后建堆，普通堆的总时间为O(N)，Leftit heaps和Skew heaps也是O(N)，从这点上来看他们并没有什么优劣。所以说ppt上说Binomial Queue优化insert是对的，但是例子不太恰当)(个人观点)</p><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>​    A binomial queue is not a heap-ordered tree, but rather a collection of heap-ordered trees, known as a forest.  Each heap-ordered tree is a binomial tree.</p><p>​        A binomial tree of height 0 is a one-node tree. A binomial tree, B<sub>k</sub> , of height k is formed by attaching a binomial tree, B<sub>k – 1</sub> , to the root of another binomial tree, B<sub>k – 1</sub> .</p><p>​    (详情见ppt)</p><p>​    Observation :B<sub>k</sub>  consists of a root with  k  children, which are B<sub>0</sub> B<sub>1</sub> B<sub>2</sub> ……B<sub>k-1</sub> ,B<sub>k</sub>  has exactly 2<sup>k</sup>    nodes.  The number of nodes at depth d is  C(k,d).</p><p>​      A priority queue of any size can be uniquely represented by a collection of binomial trees.            .(一个数能够唯一地用二进制表示)</p><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations:"></a>Operations:</h3><h5 id="FindMin"><a href="#FindMin" class="headerlink" title="FindMin:"></a>FindMin:</h5><p>​    The minimum key is in one of the roots. There are at most  logN(取上界)  roots, hence T<sub>p</sub> = O(logN).</p><p>​    Note: We can remember the minimum and update whenever it is changed.  Then this operation will take O(1).(但是会额外消耗空间)</p><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge:"></a>Merge:</h5><p>​    只需要把相同大小的子树相互连接即可，所以时间复杂度比较低，为O(logN)</p><h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert:"></a>Insert:</h5><p>​    a special case for merging</p><p>​    Note: If the smallest nonexistent binomial tree is B<sub>i</sub>  , then T<sub>p</sub>  = Const · (i + 1).Performing N Inserts on an initially empty binomial queue will take O(N) worst-case time.  Hence the average time is constant.</p><h5 id="DeleteMin-H-；"><a href="#DeleteMin-H-；" class="headerlink" title="DeleteMin(H)；"></a>DeleteMin(H)；</h5><p>​    Step 1: FindMin in B<sub>k</sub>  O(logN)</p><p>​    Step 2: Remove B<sub>k</sub> from H   O(1)</p><p>​    Step 3: Remove root from B<sub>k</sub>   O(logN)</p><p>​    Step 4: Merge(H’,H’’)   O(logN)</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Collection</span> *<span class="title">BinQueue</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span> *<span class="title">BinTree</span>;</span>  <span class="comment">/* missing from p.176 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    ElementType    Element;</span><br><span class="line">    Position    LeftChild;</span><br><span class="line">    Position     NextSibling;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Collection</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> CurrentSize;  <span class="comment">/* total number of nodes */</span></span><br><span class="line">    BinTree TheTrees[ MaxTrees ];</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BinTreeCombineTrees</span>( BinTree T1, BinTree T2 )&#123; </span><br><span class="line">    <span class="comment">/* merge equal-sized T1 and T2 */</span></span><br><span class="line">    <span class="keyword">if</span> ( T1-&gt;Element &gt; T2-&gt;Element )</span><br><span class="line">        <span class="comment">/* attach the larger one to the smaller one */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CombineTrees</span>( T2, T1 );</span><br><span class="line">    <span class="comment">/* insert T2 to the front of the children list of T1 */</span></span><br><span class="line">    T2-&gt;NextSibling = T1-&gt;LeftChild;</span><br><span class="line">    T1-&gt;LeftChild = T2;</span><br><span class="line">    <span class="keyword">return</span> T1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>T<sub>p</sub> =O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinQueue  <span class="title">Merge</span><span class="params">( BinQueue H1, BinQueue H2 )</span></span>&#123;</span><br><span class="line">    BinTree T1, T2, Carry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> ( H1-&gt;CurrentSize + H2-&gt; CurrentSize &gt; Capacity )  <span class="built_in">ErrorMessage</span>();</span><br><span class="line">    H1-&gt;CurrentSize += H2-&gt; CurrentSize;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>, j=<span class="number">1</span>; j&lt;= H1-&gt;CurrentSize; i++, j*=<span class="number">2</span> ) &#123;</span><br><span class="line">        T1 = H1-&gt;TheTrees[i]; </span><br><span class="line">        T2 = H2-&gt;TheTrees[i]; <span class="comment">/*current trees */</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>( <span class="number">4</span>*!!Carry + <span class="number">2</span>*!!T2 + !!T1 ) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 000 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* 001 */</span><span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* 010 */</span>  H1-&gt;TheTrees[i] = T2; H2-&gt;TheTrees[i]=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">/* 100 */</span>  </span><br><span class="line">                H1-&gt;TheTrees[i] = Carry; Carry = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">/* 011 */</span>  </span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T1, T2 );</span><br><span class="line">                H1-&gt;TheTrees[i] = H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">/* 101 */</span>  </span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T1, Carry );H1-&gt;TheTrees[i] = <span class="literal">NULL</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">/* 110 */</span>  </span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T2, Carry );</span><br><span class="line">                H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">/* 111 */</span>  </span><br><span class="line">                H1-&gt;TheTrees[i] = Carry; </span><br><span class="line">                Carry = <span class="built_in">CombineTrees</span>( T1, T2 ); </span><br><span class="line">                H2-&gt;TheTrees[i] = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">break</span>;&#125; <span class="comment">/* end switch */</span></span><br><span class="line">    &#125; <span class="comment">/* end for-loop */</span></span><br><span class="line">    <span class="keyword">return</span> H1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType  <span class="title">DeleteMin</span><span class="params">( BinQueue H )</span></span>&#123;</span><br><span class="line">    BinQueue DeletedQueue; </span><br><span class="line">    Position DeletedTree, OldRoot;</span><br><span class="line">    ElementType MinItem = Infinity;  <span class="comment">/* the minimum item to be returned */</span></span><br><span class="line">    <span class="keyword">int</span> i, j, MinTree; <span class="comment">/* MinTree is the index of the tree with the minimum item */</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">IsEmpty</span>( H ) )  &#123;  <span class="built_in">PrintErrorMessage</span>();  <span class="keyword">return</span> –Infinity; &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MaxTrees; i++) &#123;  </span><br><span class="line">        <span class="comment">/* Step 1: find the minimum item */</span></span><br><span class="line">        <span class="keyword">if</span>( H-&gt;TheTrees[i] &amp;&amp; H-&gt;TheTrees[i]-&gt;Element &lt; MinItem ) &#123; </span><br><span class="line">            MinItem = H-&gt;TheTrees[i]-&gt;Element;  </span><br><span class="line">            MinTree = i;    </span><br><span class="line">        &#125; <span class="comment">/* end if */</span></span><br><span class="line">    &#125; <span class="comment">/* end for-i-loop */</span></span><br><span class="line">    DeletedTree = H-&gt;TheTrees[ MinTree ];  </span><br><span class="line">    H-&gt;TheTrees[ MinTree ] = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="comment">/* Step 2: remove the MinTree from H =&gt; H’ */</span></span><br><span class="line">    OldRoot = DeletedTree;   </span><br><span class="line">    <span class="comment">/* Step 3.1: remove the root */</span></span><br><span class="line">    DeletedTree = DeletedTree-&gt;LeftChild;   </span><br><span class="line">    <span class="built_in">free</span>(OldRoot);</span><br><span class="line">    DeletedQueue = <span class="built_in">Initialize</span>();   </span><br><span class="line">    <span class="comment">/* Step 3.2: create H” */</span></span><br><span class="line">    DeletedQueue-&gt;CurrentSize = ( <span class="number">1</span>&lt;&lt;MinTree ) – <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">/* 2MinTree – 1 */</span></span><br><span class="line">    <span class="keyword">for</span> ( j = MinTree – <span class="number">1</span>; j &gt;= <span class="number">0</span>; j – – ) &#123; </span><br><span class="line">        DeletedQueue-&gt;TheTrees[j] = DeletedTree;</span><br><span class="line">        DeletedTree = DeletedTree-&gt;NextSibling;</span><br><span class="line">        DeletedQueue-&gt;TheTrees[j]-&gt;NextSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="comment">/* end for-j-loop */</span></span><br><span class="line">    H-&gt;CurrentSize  – = DeletedQueue-&gt;CurrentSize + <span class="number">1</span>;</span><br><span class="line">    H = <span class="built_in">Merge</span>( H, DeletedQueue ); </span><br><span class="line">    <span class="comment">/* Step 4: merge H’ and H” */</span></span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【Claim】"><a href="#【Claim】" class="headerlink" title="【Claim】"></a>【Claim】</h5><p>proof 1:</p><p>A binomial queue of N elements can be built by N successive insertions in O(N) time.</p><p>Total steps = N;</p><p>Total links=N(1/4+2<em>1/8+3</em>1/16……)=O(N)</p><p>proof 2:</p><p>Proof 2:</p><p>An insertion that costs c units results in a net increase of 2 – c trees in the forest.</p><p>C<sub>i</sub> ::= cost of the ith insertion</p><p>P<sub>i</sub> ::= number of trees after the ith insertion (P<sub>0</sub>  = 0)</p><p>C<sub>i</sub> + (P<sub>i</sub> – P<sub>i-1</sub> )= 2 for all i = 1, 2, …, N</p><p>Add all these equations up C<sub>i</sub> (加和)+P<sub>N</sub> -P<sub>0</sub> =2N</p><p>C<sub>i</sub> (加和)=2N-P<sub>N</sub> &lt;=2N=O(N)</p><p>T<sub>worst</sub>  = O(log N),  but T<sub>amortized</sub>  = 2</p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ADS chapter5 Skew Heaps</title>
      <link href="2021/06/02/ADS-chapter5/"/>
      <url>2021/06/02/ADS-chapter5/</url>
      
        <content type="html"><![CDATA[<h2 id="Skew-Heaps"><a href="#Skew-Heaps" class="headerlink" title="Skew Heaps"></a>Skew Heaps</h2><p>​    At first we should know that the relation between Leftist Heap and the Skew Heap is much similar to the relation between the AVL tree and the Splay tree.</p><p>​    Similarly skew heaps are also a simple version of the leftist heaps, in leftist tree we must keep an eye on the Npl, but in skew heap we don’t care about it anymore, we just blindly swap the children.</p><p>Target: Any M consecutive operations take at most O(MlogN) time.</p><p>​    这里主要看Merge操作</p><p>​    Merge: Always swap the left and right children except that the largest of all the nodes on the right paths does not have its children swapped(如果不理解这句话请看ppt，其上有演示). No Npl.</p><p>(整个merge的过程在ppt上有详细操作，不在列举)</p><p>​    Note: Skew heaps have the advantages that no extra space is required to maintain path lengths and no tests are required to determine when to swap children.</p><p>​    It is an open problem to determine precisely the expected right path length of both leftist and skew heaps.(注意这里说的是expected path length 相当于average，我已知Leftist heaps的最大right path length 是O(logN),对于skew heaps 我们可以证明它的amortized right path length是log(N)但是不知道expected path length)</p><h3 id="Amortized-Analysis-for-Skew-Heaps"><a href="#Amortized-Analysis-for-Skew-Heaps" class="headerlink" title="Amortized Analysis for Skew Heaps"></a>Amortized Analysis for Skew Heaps</h3><p>​    Insert &amp; DeleteMin are just Merge.(因为insert其实是Merge的一种特殊情况，DeleteMin是删除根节点再加上Merge)，so if we can prove that each merge will take an amortized logN time,then we are done.</p><p>​    Assume that the amortized time of Merge is T<sub>amortized</sub> =O(log(N))</p><p>​    we can prove by potential function method</p><p>​    D<sub>i</sub> = the root of the resulting tree.</p><p>​    P(D<sub>i</sub> )=number of right nodes? —&gt;not work. Why? because when we do the amortized analysis, we always assume that we start from the empty cases,so at very beginning,we have two empty heaps which means the initial value of this function is 0. And after a sequence of operations, the number of right nodes is guaranteed to be nonnegative. It satisfy the basic requirements,but this function is guaranteed to be an increasing function, or say a non-decreasing function.(因为开始时右节点是右节点，经过一次Merge之后变成左节点，下一次Merge后左边部分经过了插入再变为右节点，所以是递增的)，而一个potential function 需要反映出是好的还是坏的情况，这样的递增的是无法判断的，所以不行。</p><p>​    so we define P(D<sub>i</sub>) = number of the heavy nodes.</p><p>​    Definition: A node p is heavy if the number of descendants of p’s right subtree is at least half of the number of descendants of p, and light otherwise.  Note that the number of descendants of a node includes the node itself.(its right subtree is larger than its left subtree).</p><p>​    The only nodes whose heavy/light status can change are nodes that are initially on the right path.(在最右面路径上的heavy 必然变为light，但是最右面路径上的light不一定变为heavy)</p><p>​    所以定义H<sub>i</sub> :l<sub>i</sub> +h<sub>i</sub> (i=1 or 2)(number of nodes along the right path)———&gt; T<sub>worst</sub> =l<sub>1</sub> +h<sub>1</sub> +l<sub>2</sub> +h<sub>2</sub> </p><p>Before merge:P<sub>i</sub> =h<sub>1</sub> +h<sub>2</sub> +h                  ———-&gt;T<sub>amortized</sub> =T<sub>worst</sub> +P<sub>i+1</sub> -P<sub>i</sub> &lt;=2(l<sub>1</sub> +l<sub>2</sub> ) </p><p>After merge : P<sub>i+1</sub> &lt;=l<sub>1</sub> +l<sub>2</sub> +h</p><p>​    </p><p>.</p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ADS chapter4 Leftist Heaps</title>
      <link href="2021/06/01/ADS-chapter4/"/>
      <url>2021/06/01/ADS-chapter4/</url>
      
        <content type="html"><![CDATA[<h2 id="Leftist-Heaps"><a href="#Leftist-Heaps" class="headerlink" title="Leftist Heaps"></a>Leftist Heaps</h2><p>target: speed up merging in O(N).</p><p>​        普通堆的特性：structure property + order property（储存在binary tree中，而且是有序的，上面的都比下面的小或者大）</p><p>​        merge two heaps if we only use the original heap structure: O(N).</p><p>​        这是确定的N，而不是O(N),因为copy所有的节点需要N，而下滤操作也需要N，这样就是N了</p><p>​        if we use pointers ,we will slow down all the operations. (这是没有办法的事，想降低merge的时间复杂度就势必会用指针，而指针操作会降低速度，权衡之下左式堆用了指针)，总的来讲，从算法上说左式堆和普通的二叉堆相比，insert、deleteMin的时间复杂度没有变化，都是O(logN),但是降低了Merge的时间复杂度从N变为了O(logN),只是算法理论上。而建堆操作的话，普通的是O(N),左式堆也能算，就是把每个单个节点看成一个优先队列（堆），然后merge，然后又得到一些两个节点的堆，再merge，然后得到一些4个节点的堆，再merge……，（最后是多少我懒得算，但是一定能算，偷偷告诉你我算出来是O(N),和普通的堆一样……)。所以从算法角度上讲左式堆更加好。</p><p>​    order property–the same</p><p>​    structure property–binary tree,but unbalanced.</p><p>​    Definition: The null path length,Npl(X), of any node X is the length of the shortest path from X to a node without two children. Define Npl(NULL)=-1.</p><p>Note: Npl(X)=min{Npl(C)+1 for all C as children of X}</p><p>​    Definition: The Leftist heap property is that for every node X in the heap, the null path length of the left child is at least as large as that of the right child.</p><p>​    Theorem: A Leftist tree with r nodes on the right path must have at least 2<sup>r</sup> -1 nodes.</p><p>​    How long is the right path of a Leftist tree of N nodes?—–&gt;at most log(N+1)==O(logN)</p><p>​    If we can perform all the work on the right path,which is guaranteed to be short.</p><p>​    trouble maker: insert and merge(我觉得主要是merge是N的操作，而在普通的堆中insert的操作是O(logN))(insert is merely a special case of merging)</p><h4 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration:"></a>Declaration:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">ElementType Element;</span><br><span class="line">PriorityQueue Left;</span><br><span class="line">PriorityQueue Right;</span><br><span class="line">int Npl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Merge-recusive-version"><a href="#Merge-recusive-version" class="headerlink" title="Merge(recusive version)"></a>Merge(recusive version)</h4><p>Step 1: Merge(H1-&gt;Right,H2)</p><p>Step 2: Attach(H2,H1-&gt;Right)</p><p>Step 3: Swap(H1-&gt;Right,H1-&gt;Left)</p><p>(if necessary)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue Merge(PriorityQueue H1,PriorityQueue H2)&#123;</span><br><span class="line">if(H1==NULL)</span><br><span class="line">return H2;</span><br><span class="line">if(H2==NULL)</span><br><span class="line">return H1;</span><br><span class="line">if(H1-&gt;Element&lt;H2-&gt;Element) return Merge1(H1,H2);</span><br><span class="line">else return Merge1(H2,H1);</span><br><span class="line">&#125;</span><br><span class="line">PriorityQueue Merge1(PriorityQueue H1,PriorityQueue H2)&#123;</span><br><span class="line">if(H1-&gt;Left==NULL)</span><br><span class="line">H1-&gt;Left=H2;</span><br><span class="line">else&#123;</span><br><span class="line">H1-&gt;Right=Merge1(H1-&gt;Right,H2);</span><br><span class="line">if(H1-&gt;Left-&gt;Npl&lt;H1-&gt;Right-&gt;Npl)</span><br><span class="line">SwapChildren(H1);</span><br><span class="line">H1-&gt;Npl=H1-&gt;Right-&gt;Npl+1;</span><br><span class="line">&#125;</span><br><span class="line">return H1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    T=O(log(N))</p><p>从递归的形式上是看不出来的，建议从非递归形式上看，非递归形式也有助于做一些题目，一定要看！（见ppt，在这里无法像ppt一样一步步来）</p><h4 id="DeleteMin"><a href="#DeleteMin" class="headerlink" title="DeleteMin"></a>DeleteMin</h4><p>​    Step 1:delete the root;</p><p>​    Step 2: Merge the two subtrees</p><p>T<sub>p</sub> =O(logN) easy to think.</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/31/NP%20problems/"/>
      <url>2021/05/31/NP%20problems/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ADS chapter3 B+ Tree</title>
      <link href="2021/05/30/ADS-chapter3/"/>
      <url>2021/05/30/ADS-chapter3/</url>
      
        <content type="html"><![CDATA[<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><p>Definition: A B+ tree of order M is a tree with the following structural properties:</p><p>(1) The root is either a leaf or has between 2 and M children.</p><p>(2) All nonleaf nodes (except the root) have between M/2 (取上界)and M children.</p><p>(3) All leaves are at the same depth.(Assume each nonroot leaf also has between M/2 (取上界) and M children )</p><p>search、insert操作原理比较简单，不再过多重复</p><p>先粘贴insert的伪码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Btree  Insert ( ElementType X,  Btree T ) </span><br><span class="line">&#123; </span><br><span class="line">Search from root to leaf for X and find the proper leaf node;</span><br><span class="line"> Insert X;</span><br><span class="line"> while ( this node has M+1 keys ) &#123;</span><br><span class="line"> split it into 2 nodes with (M+1)/2(取上界) and (M+1)/2(取下界) keys, respectively;</span><br><span class="line"> if (this node is the root)</span><br><span class="line"> create a new root with two children;</span><br><span class="line"> check its parent;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Depth(M,N)=O(log<sub>M/2</sub> N)</p><p>T(M,N)=O((M/logM)logN)</p><p>T<sub>Find</sub> (M,N)=O(logN)(因为find操作的时间复杂度只依赖于该点的深度即Depth(M,N)).</p><p>delete的操作:(可能不是重点，因为mooc上没讲，但是还是了解一下比较好~)。</p><p>1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于M/2 取上界，删除操作结束,否则执行第2步。</p><p>2）若兄弟结点key有富余（大于M/2(取上界)），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p><p>3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p><p>4）若索引结点的key的个数大于等于M/2(取上界)，则删除操作结束。否则执行第5步</p><p>5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p><p>6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p><p>***注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ADS chapter2 RB Tree</title>
      <link href="2021/05/29/ADS-chapter2/"/>
      <url>2021/05/29/ADS-chapter2/</url>
      
        <content type="html"><![CDATA[<h2 id="Red-and-Black-Trees"><a href="#Red-and-Black-Trees" class="headerlink" title="Red and Black Trees"></a>Red and Black Trees</h2><p>Target: Balanced binary search tree</p><p>结构：一般键值，左孩子指针、右孩子指针、父指针，颜色域。</p><p>Definition: binary search tree</p><p>​                    (1) every node is either red or black</p><p>​                    (2)root is black</p><p>​                    (3) every leaf is black</p><p>​                    (4) if a node is red,then both its children are black;</p><p>​                    (5)For each node,all simple paths from the node to descendant leaves contain the same number of black nodes.</p><p>Definition: The black-height of any node x—-&gt;(bh(x)), is the number of black nodes on any simple path from x(x is not included) down to a leaf. bh(Tree)=bh(root).</p><p>Lemma :A red-black tree with N internal nodes has height at most 2ln(N+1).</p><p>Proof: (1) For any node x,sizeof(x)&gt;=2<sup>bh(x)</sup> -1(归纳法证明)Prove by induction.</p><p>​            if h(x)=0,x is NULL —-&gt; sizeof(x)=0 √</p><p>​            suppose it is true for all x with h(x)&lt;k.</p><p>​            For x with h(x)=k+1,bh(child)=bh(x)-1 or bh(x)</p><p>​            Since h(child)&lt;=k ,sizeof(child)&gt;=2<sup>bh(child)</sup> -1&gt;=2<sup>bh(x)-1</sup> -1</p><p>​            hence sizeof(x)=2*sizeof(child)+1&gt;=2<sup>bh(x)</sup> -1.</p><p>Then sizeof(root)&gt;=2<sup>bh(x)</sup> -1,即N&gt;=2<sup>bh(x)</sup> -1,bh(tree)&lt;=log(N+1)</p><p>if we can prove bh(tree)&gt;=h(tree)/2, then we can prove h(tree)&lt;=2*log(N+1).</p><p>and bh(tree)&gt;=h(tree) is easy to prove.</p><p>Insert</p><p>1、红色节点插入到黑色节点下，直接插入即可。</p><p>2、红色节点插入到红色节点下，插入之后需要交换父节点与祖父节点的颜色，红—-&gt;黑，黑—-&gt;红</p><p>当然这样做会导致祖父节点变为红色，当祖父节点的父节点也为红色时会产生冲突，也就是情况三。</p><p>3、（情况见2）具体情况说不清，见ADS的PPT</p><p>对称情况同上</p><p>插入时间复杂度 T=O(h)=O(lnN).</p><p>Deletion</p><p>1、Delete a leaf node: Reset its parent link to NULL</p><p>2、Delete a degree 1 node: Replace the node by its single child.</p><p>3、Delete a degree 2 node:</p><p>​    (1)Replace the node by the largest one in its left subtree or the smallest one in its right subtree.(keep the color)</p><p>​    (2)Delete the replacing node from the subtree.</p><p>(以上操作和binary tree的删除操作相同)</p><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVL Tree </tag>
            
            <tag> Splay Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADS chapter1 AVL tree and Splay tree</title>
      <link href="2021/05/29/ADS-chapter1/"/>
      <url>2021/05/29/ADS-chapter1/</url>
      
        <content type="html"><![CDATA[<h2 id="ADS-chapter1"><a href="#ADS-chapter1" class="headerlink" title="ADS chapter1"></a><center>ADS chapter1</center></h2><h3 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL  Tree"></a><left>AVL  Tree</left></h3><p>Target: speed up searching (with insertion and deletion)</p><p>​        (为什么不用binary search tree?虽然binary search tree的所有操作时间复杂度均为O(logN),即为与树高成正比，但是当最坏情况时，树高可能为O(N),使得binary search tree 的效果很不理想)</p><p>Definition: An empty binary tree is height balanced. If T is a nonempty binary tree with T <sub>L</sub> and T<sub>R</sub> as its left and right subtree,then T is height balanced if and only if</p><p>(1)T<sub>L</sub> and T<sub>R</sub> are height balanced,and </p><p>(2)| h<sub>L</sub> - h<sub>R</sub> |&lt;=1 where h<sub>L</sub> and h<sub>R</sub> are the heights of T<sub>L</sub> and T<sub>R</sub> ,respectively.</p><p>(The balanced factor BF(node)=h<sub>L</sub> - h<sub>R</sub> .In an AVL tree,BF(node)=-1 1 or 0)</p><p>(注: height of an empty tree is defined to be -1)</p><p>​        AVL Tree 最重要的特性或者说需要掌握的是旋转，有single rotation还有double rotation,首先需要找到不平衡的节点（若有多个不平衡的节点，找最下面的），也就是|BF|&gt;1的点，然后看从该点到造成麻烦的节点是怎样走的，如果是LL或者RR，只需要一次右旋或者左旋即可；如果是LR，则先对中间节点进行一次左旋，转成LL，然后进行右旋；如果是RL，则先对中间节点进行一次右旋，变成RR，然后进行左旋即可。</p><p>​        AVL Tree本身就是一个binary search tree，所以说AVL Tree的各项操作也是和树的高度成正比的，T<sub>p</sub> =O(h)，那么height为多少？O(logN),证明如下：</p><p>​        Let n<sub>h</sub> be the minimum number of nodes in a height balanced tree of height h. Then the tree has a relation n<sub>h</sub> =n<sub>h-1</sub> + n<sub>h-2</sub> +1(looks like Fibonacci numbers),n<sub>h</sub> =F<sub>h+2</sub> -1, F<sub>i</sub> ~(k)<sup>i</sup></p><p>(k为常数),所以n<sub>h</sub> ~(k)<sup>h</sup> ,得h=logn, height=O(logn).得证。</p><h3 id="Splay-Tree"><a href="#Splay-Tree" class="headerlink" title="Splay Tree"></a><left>Splay Tree</left></h3><p>Target: any M consecutive tree operations starting from an empty tree take at most O(MlogN) time.(AVL tree is a Splay tree but a Splay tree may be not an AVL tree).</p><p>Idea: after the node is accessed, it is pushed to the root by aseries of AVL tree rotations.</p><p>(查询、插入均如此)</p><p>For any nonroot node X, denote its parent by P and grandparent by G.</p><p>case 1:P is the root—–&gt; Rotate X and P</p><p>case 2:P is not the root ——-&gt;zigzag : 两次旋转,P和X进行一次旋转，之后X和G再进行一次旋转.</p><p>zigzig: 一次旋转,P和G直接进行一次旋转即可</p><p>(删除)</p><p>Step 1:Find X(after that,X will be the root)</p><p>Step 2: Remove X(after that there will be two subtrees T<sub>L</sub> T<sub>R</sub> )</p><p>Step 3: FindMax(T<sub>L</sub> );(左子树得最大元素会成为左子树得新根，这个子树一定没有右子树)</p><p>Step 4: Make T<sub>R</sub> the right child of the root of T<sub>L</sub> </p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVL Tree </tag>
            
            <tag> Splay Tree </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
